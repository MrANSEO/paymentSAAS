// server.js
require('dotenv').config();
const express = require('express');
const connectDB = require('./src/config/database');
const securityMiddleware = require('./src/middleware/security');

// Routes
const authRoutes = require('./src/routes/authRoutes');
const paymentRoutes = require('./src/routes/paymentRoutes');
const webhookRoutes = require('./src/routes/webhookRoutes');

const app = express();
const PORT = process.env.PORT || 3000;

// Connexion base de donn√©es
connectDB();
app.set('trust proxy', 1);

// Middleware de s√©curit√©
app.use(securityMiddleware.helmet());
app.use(securityMiddleware.corsMiddleware);
app.use(securityMiddleware.limiter);

// ‚ö†Ô∏è IMPORTANT : raw body pour le webhook (avant le JSON global)
// on garde le buffer brut dans req.rawBody via l'option verify
app.use(
  '/api/v1/webhooks/mesomb',
  express.raw({
    type: 'application/json',
    limit: '10mb',
    verify: (req, res, buf /*, encoding */) => {
      req.rawBody = buf;
    }
  })
);

// Middleware pour parser le JSON (pour les autres routes)
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Logger des requ√™tes
app.use((req, res, next) => {
  console.log(`  ${req.method} ${req.path} - ${new Date().toISOString()}`);
  next();
});

// Routes
app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/payments', paymentRoutes);
app.use('/api/v1/webhooks', webhookRoutes);

// Route sant√©
app.get('/health', (req, res) => {
  res.status(200).json({
    success: true,
    message: 'API Payment SaaS en fonctionnement',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    environment: process.env.NODE_ENV
  });
});

// Middleware global d'erreurs
app.use((err, req, res, next) => {
  console.error('‚ùå Erreur non g√©r√©e:', err);
  const message = process.env.NODE_ENV === 'development' ? err.message : 'Erreur serveur interne';
  res.status(500).json({
    success: false,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// D√©marrage du serveur
app.listen(PORT, '0.0.0.0', () => {
  console.log(`  Serveur d√©marr√© sur le port ${PORT}`);
  console.log(`  Environnement: ${process.env.NODE_ENV}`);
  console.log(`  Health check: http://localhost:${PORT}/health`);
});

module.exports = app;
# MeSomb Configuration
MESOMB_API_KEY=4857b474-8fd3-4e52-846b-2141df99b1c8
MESOMB_SECRET_KEY=dc585a67-216c-497d-8be4-5adb033b390a
MESOMB_BASE_URL=https://mesomb.hachther.com/api/v1.1
MESOMB_APP_KEY=77a469329c0c3763762a4b72979d25768bb4a9d4
# Application
PORT=3000
JWT_SECRET=votre_secret_jwt_super_securise
NODE_ENV=development

# Database
MONGODB_URI=mongodb+srv://ahmed:ahmedo90210@cluster0.rjxboax.mongodb.net/

# Email Configuration (√Ä CONFIGURER pour la production)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=votre-email@gmail.com
SMTP_PASS=votre-mot-de-passe-app
SMTP_FROM=noreply@votre-saas.com

// src/services/notificationService.js
const axios = require('axios');

class NotificationService {
  // Envoi de SMS (simulation en dev)
  async sendPaymentConfirmation(phone, amount, reference) {
    console.log(`üì± [SMS SIMUL√â] Envoy√© √† ${phone}: "Veuillez confirmer le paiement de ${amount} FCFA. R√©f: ${reference}"`);
    return { success: true };
  }

  async sendPaymentSuccess(phone, amount, reference) {
    console.log(`‚úÖ [SMS SIMUL√â] Succ√®s √† ${phone}: "Paiement de ${amount} FCFA confirm√©. R√©f: ${reference}"`);
    return { success: true };
  }

  async sendPaymentFailure(phone, amount, reference, reason = '√âchec du paiement') {
    console.log(`‚ùå [SMS SIMUL√â] √âchec √† ${phone}: "Paiement de ${amount} FCFA √©chou√©. Raison: ${reason}. R√©f: ${reference}"`);
    return { success: true };
  }

  // üîë ENVOI WEBHOOK AU MARCHAND (essentiel)
  async notifyMerchant(webhookUrl, payload) {
    if (!webhookUrl) {
      console.warn('‚ö†Ô∏è Webhook URL absente ‚Üí notification ignor√©e');
      return { success: false, error: 'Webhook URL manquante' };
    }

    try {
      console.log(`üì° Envoi webhook √†: ${webhookUrl}`);
      console.log('üì¶ Payload:', JSON.stringify(payload, null, 2));

      const response = await axios.post(webhookUrl, payload, {
        timeout: 5000,
        headers: { 'Content-Type': 'application/json' }
      });

      console.log(`‚úÖ Webhook re√ßu par le marchand (status: ${response.status})`);
      return { success: true, status: response.status };
    } catch (error) {
      console.error(`‚ùå √âchec webhook ‚Üí ${error.message}`);
      return { success: false, error: error.message };
    }
  }
}

module.exports = new NotificationService();
// src/services/mesombOfficialService.js
const { PaymentOperation } = require('@hachther/mesomb');

class MeSombOfficialService {
  constructor() {
    this.applicationKey = process.env.MESOMB_APP_KEY;
    this.accessKey = process.env.MESOMB_API_KEY;
    this.secretKey = process.env.MESOMB_SECRET_KEY;
  }

  async makePayment(amount, phone, operator) {
    try {
      console.log('üöÄ Appel √† MeSomb (sandbox)...');
      console.log(`üìû Num√©ro: ${phone} | Montant: ${amount} | Op√©rateur: ${operator}`);

      const client = new PaymentOperation({
        applicationKey: this.applicationKey,
        accessKey: this.accessKey,
        secretKey: this.secretKey
      });

      const service = operator === 'ORANGE' ? 'ORANGE' : 'MTN';

      const response = await client.makeCollect({
        payer: phone,
        amount: amount,
        service: service,
        country: 'CM',
        currency: 'XAF'
      });

      console.log('‚úÖ R√©ponse MeSomb (initiation):', {
        operationSuccess: response.isOperationSuccess(),
        transactionSuccess: response.isTransactionSuccess(),
        transactionId: response.transaction?.pk
        // ‚ö†Ô∏è NE PAS UTILISER response.status pour d√©terminer le succ√®s final
      });

      // üîë CORRECTION : on ne retourne PAS de statut ici
      // Le vrai statut vient UNIQUEMENT du webhook
      if (response.isOperationSuccess() && response.isTransactionSuccess()) {
        return {
          success: true,
          data: {
            transactionId: response.transaction?.pk,
            message: 'Paiement initi√© avec succ√®s'
          }
        };
      } else {
        return {
          success: false,
          error: '√âchec de l‚Äôinitiation du paiement'
        };
      }

    } catch (error) {
      console.error('‚ùå Erreur MeSomb (officiel):', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async checkTransactionStatus(transactionId) {
    try {
      const client = new PaymentOperation({
        applicationKey: this.applicationKey,
        accessKey: this.accessKey,
        secretKey: this.secretKey
      });

      const transactions = await client.getTransactions([transactionId]);

      if (transactions && transactions.length > 0) {
        return {
          success: true,
          data: transactions[0]
        };
      } else {
        return {
          success: false,
          error: 'Transaction non trouv√©e'
        };
      }
    } catch (error) {
      console.error('‚ùå Erreur v√©rification statut MeSomb:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

module.exports = new MeSombOfficialService();
const express = require('express');
const router = express.Router();
const webhookController = require('../controllers/webhookController');

// Webhook MeSomb
router.post('/mesomb', webhookController.handleMeSombWebhook);

module.exports = router;
const express = require('express');
const router = express.Router();
const paymentController = require('../controllers/paymentController');
const { validateInitiatePayment, handleValidationErrors } = require('../middleware/validation');

// ‚úÖ Validation + traitement
router.post('/initiate', validateInitiatePayment, handleValidationErrors, paymentController.initiatePayment);

router.get('/status/:reference', paymentController.checkPaymentStatus);
router.get('/merchant/:merchant_id', paymentController.getMerchantTransactions);

module.exports = router;

const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { validateRegister, handleValidationErrors } = require('../middleware/validation');

router.post('/register', validateRegister, handleValidationErrors, authController.register);
router.post('/login', authController.login);

module.exports = router;
const mongoose = require('mongoose');

const transactionSchema = new mongoose.Schema({
  reference: {
    type: String,
    required: true,
    unique: true
  },
  amount: {
    type: Number,
    required: true
  },
  currency: {
    type: String,
    default: 'XAF'
  },
  customer_phone: {
    type: String,
    required: true
  },
  operator: {
    type: String,
    enum: ['ORANGE', 'MTN'],
    required: true
  },
  status: {
    type: String,
    enum: ['PENDING', 'SUCCESS', 'FAILED', 'EXPIRED', 'REFUNDED'],
    default: 'PENDING'
  },
  mesomb_transaction_id: {
    type: String
  },
  merchant_id: {
    type: String,
    required: true
  },
  metadata: {
    type: Object,
    default: {}
  }
}, {
  timestamps: true
});

// Index pour les recherches rapides
transactionSchema.index({ reference: 1 });
transactionSchema.index({ customer_phone: 1 });
transactionSchema.index({ status: 1 });
transactionSchema.index({ createdAt: 1 });

module.exports = mongoose.model('Transaction', transactionSchema);
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const merchantSchema = new mongoose.Schema({
  company_name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  phone: {
    type: String,
    required: true
  },
  webhook_url: {
    type: String
  },
  is_active: {
    type: Boolean,
    default: true
  },
  api_key: {
    type: String,
    unique: true
  }
}, {
  timestamps: true
});

// Hash password avant sauvegarde
merchantSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// G√©n√©rer API Key
merchantSchema.methods.generateApiKey = function() {
  this.api_key = require('crypto').randomBytes(32).toString('hex');
};

module.exports = mongoose.model('Merchant', merchantSchema);
// src/middleware/validation.js
const { body, validationResult } = require('express-validator');

// Validation pour /payments/initiate
const validateInitiatePayment = [
  // Montant : entier ‚â• 10 000 FCFA
  body('amount')
    .isInt({ min: 10000 })
    .withMessage('Le montant doit √™tre un entier d‚Äôau moins 10 000 FCFA'),

  // Num√©ro de t√©l√©phone camerounais : 12 chiffres commen√ßant par 237
  body('customer_phone')
    .matches(/^237[0-9]{9}$/)
    .withMessage('Le num√©ro doit √™tre un num√©ro camerounais valide (12 chiffres commen√ßant par 237)'),

  // Op√©rateur : uniquement ORANGE ou MTN
  body('operator')
    .isIn(['ORANGE', 'MTN'])
    .withMessage('Op√©rateur doit √™tre ORANGE ou MTN'),

  // merchant_id : doit √™tre une cha√Æne non vide (on ne force pas ObjectId ici car tu l‚Äôutilises comme string)
  body('merchant_id')
    .isString()
    .notEmpty()
    .withMessage('merchant_id est requis')
];

// Validation pour l‚Äôinscription marchand
const validateRegister = [
  body('company_name').notEmpty().withMessage('Nom de l‚Äôentreprise requis'),
  body('email').isEmail().withMessage('Email invalide'),
  body('password').isLength({ min: 6 }).withMessage('Mot de passe ‚â• 6 caract√®res'),
  body('phone')
    .matches(/^237[0-9]{9}$/)
    .withMessage('T√©l√©phone marchand : num√©ro camerounais valide requis (12 chiffres)')
];

// Middleware central pour retourner les erreurs de validation
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Donn√©es invalides',
      errors: errors.array({ onlyFirstError: true }) // Une seule erreur par champ
    });
  }
  next();
};

module.exports = {
  validateInitiatePayment,
  validateRegister,
  handleValidationErrors
};
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');

// Configuration CORS
const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  optionsSuccessStatus: 200
};

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limite chaque IP √† 100 requ√™tes par windowMs
});

// Middleware CORS configur√©
const corsMiddleware = cors(corsOptions);

module.exports = {
  corsMiddleware, 
  limiter,
  helmet
};
// src/middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  // Log d√©taill√© en mode d√©veloppement
  if (process.env.NODE_ENV === 'development') {
    console.error('‚ùå Erreur non g√©r√©e:', {
      message: err.message,
      stack: err.stack,
      url: req.originalUrl,
      method: req.method
    });
  }

  // D√©finir le code de statut (par d√©faut 500)
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Erreur serveur interne',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

module.exports = errorHandler;
const jwt = require('jsonwebtoken');
const Merchant = require('../models/Merchant');

// V√©rifier le token JWT
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token d\'acc√®s manquant'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback_secret');
    req.merchantId = decoded.merchantId;
    next();
  } catch (error) {
    return res.status(403).json({
      success: false,
      message: 'Token invalide'
    });
  }
};

// V√©rifier la cl√© API
const authenticateApiKey = async (req, res, next) => {
  try {
    const apiKey = req.headers['x-api-key'];

    if (!apiKey) {
      return res.status(401).json({
        success: false,
        message: 'Cl√© API manquante'
      });
    }

    const merchant = await Merchant.findOne({ api_key: apiKey });
    if (!merchant) {
      return res.status(403).json({
        success: false,
        message: 'Cl√© API invalide'
      });
    }

    req.merchant = merchant;
    next();
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: 'Erreur d\'authentification'
    });
  }
};

module.exports = {
  authenticateToken,
  authenticateApiKey
};
// src/controllers/webhookController.js
const crypto = require('crypto');
const Transaction = require('../models/Transaction');
const Merchant = require('../models/Merchant');
const NotificationService = require('../services/notificationService');

class WebhookController {
  verifySignature(payloadBuffer, signature, secret) {
    try {
      if (!payloadBuffer || !signature || !secret) return false;

      // HMAC sous forme raw Buffer
      const computedBuf = crypto.createHmac('sha256', secret).update(payloadBuffer).digest(); // Buffer

      // essayer d'interpr√©ter la signature en hex puis en base64
      let sigBuf = null;
      // tentative hex
      try {
        sigBuf = Buffer.from(String(signature).trim(), 'hex');
        if (sigBuf.length !== computedBuf.length) sigBuf = null;
      } catch (e) {
        sigBuf = null;
      }
      // tentative base64 si hex non ok
      if (!sigBuf) {
        try {
          sigBuf = Buffer.from(String(signature).trim(), 'base64');
          if (sigBuf.length !== computedBuf.length) sigBuf = null;
        } catch (e) {
          sigBuf = null;
        }
      }

      if (!sigBuf) return false;

      return crypto.timingSafeEqual(computedBuf, sigBuf);
    } catch (err) {
      return false;
    }
  }

  async handleMeSombWebhook(req, res) {
    try {
      // accepter plusieurs noms d'ent√™te possibles
      const signature =
        req.headers['x-signature'] ||
        req.headers['x-mesomb-signature'] ||
        req.headers['signature'] ||
        req.headers['x-hub-signature'] ||
        req.headers['x-signature-256'];

      const secret = process.env.MESOMB_SECRET_KEY;

      if (!signature || !secret) {
        return res.status(400).json({ success: false, message: 'Signature manquante' });
      }

      // le raw buffer peut √™tre dans req.rawBody (server.js) ou req.body si express.raw n'est pas utilis√©
      const payloadBuffer = req.rawBody || (Buffer.isBuffer(req.body) ? req.body : Buffer.from(JSON.stringify(req.body || {})));

      if (!this.verifySignature(payloadBuffer, signature, secret)) {
        console.log('üîç Signature invalide. Donn√©es re√ßues:', payloadBuffer?.toString());
        return res.status(401).json({ success: false, message: 'Signature invalide' });
      }

      // parser le buffer en JSON
      const payload = JSON.parse(payloadBuffer.toString());
      const { pk, status, reference, amount, customer } = payload;
      console.log('üîî Webhook MeSomb re√ßu:', { reference, status, pk });

      const transaction = await Transaction.findOne({
        $or: [{ reference }, { mesomb_transaction_id: pk }]
      });

      if (!transaction) {
        return res.status(404).json({ success: false, message: 'Transaction introuvable' });
      }

      const statusMap = { SUCCESS: 'SUCCESS', FAILED: 'FAILED', PENDING: 'PENDING', REFUNDED: 'REFUNDED', EXPIRED: 'EXPIRED' };
      const newStatus = statusMap[status] || 'PENDING';

      if (transaction.status !== newStatus) {
        await Transaction.findByIdAndUpdate(transaction._id, {
          status: newStatus,
          mesomb_transaction_id: pk
        });
        console.log(`üîÑ Mise √† jour statut: ${transaction.reference} ‚Üí ${newStatus}`);
      }

      if (newStatus === 'SUCCESS') {
        await NotificationService.sendPaymentSuccess(transaction.customer_phone, transaction.amount, transaction.reference);
      } else if (newStatus === 'FAILED') {
        await NotificationService.sendPaymentFailure(transaction.customer_phone, transaction.amount, transaction.reference);
      }

      if (transaction.merchant_id) {
        const merchant = await Merchant.findById(transaction.merchant_id);
        if (merchant?.webhook_url) {
          const webhookPayload = {
            event: 'payment.updated',
            data: {
              reference: transaction.reference,
              amount: transaction.amount,
              currency: transaction.currency || 'XAF',
              customer_phone: transaction.customer_phone,
              status: newStatus,
              operator: transaction.operator,
              timestamp: new Date().toISOString()
            }
          };
          try {
            await NotificationService.notifyMerchant(merchant.webhook_url, webhookPayload);
          } catch (err) {
            console.error('Erreur lors de la notification du marchand:', err);
          }
        }
      }

      return res.status(200).json({ success: true, message: 'Webhook trait√©' });
    } catch (err) {
      console.error('‚ùå Erreur webhook:', err);
      return res.status(500).json({ success: false, message: 'Erreur serveur' });
    }
  }
}

// ‚úÖ Binding obligatoire pour pr√©server `this`
const instance = new WebhookController();
module.exports = {
  handleMeSombWebhook: instance.handleMeSombWebhook.bind(instance)
};
// src/controllers/paymentController.js
const Transaction = require('../models/Transaction');
const MeSombService = require('../services/mesombOfficialService');
const NotificationService = require('../services/notificationService');
const { v4: uuidv4 } = require('uuid');

class PaymentController {
  async initiatePayment(req, res) {
    try {
      const { amount, customer_phone, operator, merchant_id, metadata } = req.body;

      // ‚úÖ Validation d√©j√† g√©r√©e par middleware (express-validator)

      const reference = `TX-${uuidv4().substring(0, 8).toUpperCase()}`;
      const transaction = new Transaction({
        reference,
        amount,
        customer_phone,
        operator,
        merchant_id,
        metadata: metadata || {},
        status: 'PENDING' // üîë Toujours PENDING au d√©but
      });
      await transaction.save();

      console.log(`üí∞ Paiement initi√©: ${reference}`);
      await NotificationService.sendPaymentConfirmation(customer_phone, amount, reference);

      // Appel MeSomb pour initier le paiement
      const paymentResult = await MeSombService.makePayment(amount, customer_phone, operator);

      if (!paymentResult.success) {
        // √âchec d'initiation (ex: cl√©s invalides, service non activ√©)
        await Transaction.findByIdAndUpdate(transaction._id, {
          status: 'FAILED',
          metadata: { ...metadata, error: paymentResult.error }
        });
        await NotificationService.sendPaymentFailure(customer_phone, amount, reference, paymentResult.error);
        return res.status(400).json({ success: false, message: '√âchec MeSomb', error: paymentResult.error });
      }

      // ‚úÖ On sauvegarde l'ID MeSomb, mais PAS le statut
      await Transaction.findByIdAndUpdate(transaction._id, {
        mesomb_transaction_id: paymentResult.data.transactionId
      });

      res.status(200).json({
        success: true,
        message: 'Paiement initi√© ‚Äì confirmez sur votre t√©l√©phone',
        data: {
          reference,
          transaction_id: paymentResult.data.transactionId,
          status: 'PENDING'
        }
      });
    } catch (error) {
      console.error('‚ùå Erreur paiement:', error);
      res.status(500).json({ success: false, message: 'Erreur serveur' });
    }
  }

  // üîí Lecture seule du statut (ne PAS appeler MeSomb ici)
  async checkPaymentStatus(req, res) {
    try {
      const { reference } = req.params;
      const transaction = await Transaction.findOne({ reference });
      if (!transaction) {
        return res.status(404).json({ success: false, message: 'Transaction introuvable' });
      }

      // üö´ SUPPRESSION du polling vers MeSomb
      // Le statut est mis √† jour UNIQUEMENT par le webhook

      res.status(200).json({
        success: true,
        data: {
          reference: transaction.reference,
          amount: transaction.amount,
          status: transaction.status, // ‚Üê √âtat stock√© en base (venant du webhook)
          operator: transaction.operator,
          created_at: transaction.createdAt
        }
      });
    } catch (error) {
      console.error('‚ùå Erreur statut:', error);
      res.status(500).json({ success: false, message: 'Erreur serveur' });
    }
  }

  async getMerchantTransactions(req, res) {
    try {
      const { merchant_id } = req.params;
      const transactions = await Transaction.find({ merchant_id })
        .sort({ createdAt: -1 })
        .limit(20);
      res.json({ success: true, data: { transactions } });
    } catch (error) {
      console.error('‚ùå Erreur historique marchand:', error);
      res.status(500).json({ success: false, message: 'Erreur serveur' });
    }
  }
}

module.exports = new PaymentController();
const Merchant = require('../models/Merchant');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class AuthController {
  // Inscription d'un marchand
  async register(req, res) {
    try {
      const { company_name, email, password, phone, webhook_url } = req.body;

      //  VALIDATION DES CHAMPS OBLIGATOIRES
      if (!company_name || !email || !password || !phone) {
        return res.status(400).json({
          success: false,
          message: 'Champs manquants: company_name, email, password, phone requis'
        });
      }

      // Validation du format email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          success: false,
          message: 'Format d\'email invalide'
        });
      }

      // Validation de la longueur du mot de passe
      if (password.length < 6) {
        return res.status(400).json({
          success: false,
          message: 'Le mot de passe doit contenir au moins 6 caract√®res'
        });
      }

      // Validation du format du t√©l√©phone (basique)
      const phoneRegex = /^[0-9+-\s()]{8,20}$/;
      if (!phoneRegex.test(phone)) {
        return res.status(400).json({
          success: false,
          message: 'Format de t√©l√©phone invalide'
        });
      }

      // V√©rifier si le marchand existe d√©j√† par email ou nom d'entreprise
      const existingMerchant = await Merchant.findOne({ 
        $or: [
          { email: email.toLowerCase().trim() },
          { company_name: company_name.trim() }
        ]
      });

      if (existingMerchant) {
        const message = existingMerchant.email === email.toLowerCase() 
          ? 'Un marchand avec cet email existe d√©j√†' 
          : 'Un marchand avec ce nom d\'entreprise existe d√©j√†';
        
        return res.status(400).json({
          success: false,
          message
        });
      }

      // Cr√©er le marchand avec donn√©es nettoy√©es
      const merchant = new Merchant({
        company_name: company_name.trim(),
        email: email.toLowerCase().trim(),
        password: password,
        phone: phone.trim(),
        webhook_url: webhook_url ? webhook_url.trim() : ''
      });

      // G√©n√©rer une cl√© API s√©curis√©e
      merchant.api_key = `pk_${crypto.randomBytes(24).toString('hex')}`;

      await merchant.save();

      // Ne pas renvoyer le mot de passe dans la r√©ponse
      const merchantResponse = {
        id: merchant._id,
        company_name: merchant.company_name,
        email: merchant.email,
        phone: merchant.phone,
        webhook_url: merchant.webhook_url,
        api_key: merchant.api_key,
        is_active: merchant.is_active,
        created_at: merchant.createdAt
      };

      res.status(201).json({
        success: true,
        message: 'Marchand inscrit avec succ√®s',
        data: {
          merchant: merchantResponse
        }
      });

    } catch (error) {
      console.error('Erreur inscription:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur interne du serveur',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }

  // Connexion d'un marchand
  async login(req, res) {
    try {
      const { email, password } = req.body;

      // Validation des champs requis
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: 'Email et mot de passe requis'
        });
      }

      // V√©rifier si le marchand existe
      const merchant = await Merchant.findOne({ 
        email: email.toLowerCase().trim() 
      });

      if (!merchant) {
        return res.status(400).json({
          success: false,
          message: 'Email ou mot de passe incorrect'
        });
      }

      // V√©rifier si le compte est actif
      if (!merchant.is_active) {
        return res.status(403).json({
          success: false,
          message: 'Compte d√©sactiv√©. Contactez l\'administrateur.'
        });
      }

      // V√©rifier le mot de passe
      const isPasswordValid = await bcrypt.compare(password, merchant.password);
      if (!isPasswordValid) {
        return res.status(400).json({
          success: false,
          message: 'Email ou mot de passe incorrect'
        });
      }

      // G√©n√©rer un token JWT s√©curis√©
      const token = jwt.sign(
        { 
          merchantId: merchant._id,
          email: merchant.email
        },
        process.env.JWT_SECRET || 'votre_super_secret_jwt_tres_securise_ici',
        { expiresIn: '24h' }
      );

      // Donn√©es du marchand √† renvoyer (sans informations sensibles)
      const merchantResponse = {
        id: merchant._id,
        company_name: merchant.company_name,
        email: merchant.email,
        phone: merchant.phone,
        webhook_url: merchant.webhook_url,
        api_key: merchant.api_key,
        is_active: merchant.is_active
      };

      res.status(200).json({
        success: true,
        message: 'Connexion r√©ussie',
        data: {
          merchant: merchantResponse,
          token,
          expires_in: '24h'
        }
      });

    } catch (error) {
      console.error('Erreur connexion:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur interne du serveur',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }

  // NOUVELLE M√âTHODE : R√©cup√©rer le profil (optionnelle mais utile)
  async getProfile(req, res) {
    try {
      const merchant = await Merchant.findById(req.merchantId).select('-password');
      
      if (!merchant) {
        return res.status(404).json({
          success: false,
          message: 'Marchand non trouv√©'
        });
      }

      res.status(200).json({
        success: true,
        data: {
          merchant
        }
      });

    } catch (error) {
      console.error('Erreur r√©cup√©ration profil:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur interne du serveur',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }

  // NOUVELLE M√âTHODE : R√©g√©n√©rer la cl√© API (optionnelle mais utile)
  async regenerateApiKey(req, res) {
    try {
      const merchant = await Merchant.findById(req.merchantId);
      
      if (!merchant) {
        return res.status(404).json({
          success: false,
          message: 'Marchand non trouv√©'
        });
      }

      // G√©n√©rer une nouvelle cl√© API
      const newApiKey = `pk_${crypto.randomBytes(24).toString('hex')}`;
      merchant.api_key = newApiKey;
      
      await merchant.save();

      res.status(200).json({
        success: true,
        message: 'Cl√© API r√©g√©n√©r√©e avec succ√®s',
        data: {
          new_api_key: newApiKey
        }
      });

    } catch (error) {
      console.error(' Erreur r√©g√©n√©ration cl√© API:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur interne du serveur',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}

module.exports = new AuthController();
module.exports = {
  apiKey: process.env.MESOMB_API_KEY,
  appKey: process.env.MESOMB_APP_KEY,
  secretKey: process.env.MESOMB_SECRET_KEY,
  baseURL: process.env.MESOMB_BASE_URL || 'https://mesomb.hachther.com/api/v1.1'
};
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/payment-saas');
    console.log(`MongoDB connect√©: ${conn.connection.host}`);
  } catch (error) {
    console.error('Erreur MongoDB:', error);
    process.exit(1);
  }
};

module.exports = connectDB;